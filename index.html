<html>
	<head>
		<meta charset="UTF-8">
		<title>Squary Adventure</title>
		<style>
			body {
				background-color: lightblue;
			}
			#main-div {
		     width: 400px;
		     height:360px;
		     margin: 0px auto;
		     margin-top: 70px;
    		 vertical-align: middle;

		   }
		   #title {
		   	text-align: center;
		   	color: #fff;
			text-shadow: 0px 1px 0px #999, 0px 2px 0px #888, 0px 3px 0px #777, 0px 4px 0px #666, 0px 5px 0px #555, 0px 6px 0px #444, 0px 7px 0px #333, 0px 8px 7px #001135;
			font: 60px 'ChunkFiveRegular';
		   }
		</style>
		<!--<script type="text/javascript" src="square.min.js" ></script>-->
		<script type="text/javascript" src="src/Renderer/Renderer.js" ></script>
		<script type="text/javascript" src="src/Collision/CollisionManager.js" ></script>
		<script type="text/javascript" src="src/Game/Scene.js" ></script>
		<script type="text/javascript" src="src/Game/GameObjects.js" ></script>
	</head>
	<body onload='play()'>
		<!--<div id='title'>Squary adventure</div>-->
		<div>
			<canvas id="mycanvas" width="400" height="360" style="border:1px solid #000;">
				Your browser does not support canvas!
			</canvas>	
		</div>
		<script>

			var direction = {
	            RIGHT : 39,
	            LEFT  : 37,
	            UP    : 38,
	            DOWN  : 40
	        };

	        var sceneWidth = 400, sceneHeight = 360;

			var friction = 1.6;
			var gravity = 0.4;
			var bounce = 7;
			var lifetime = 50; // seconds

			function createFileLoader(file, callback) {
				return new Promise(function(resolve, reject) {
					var xhr = new XMLHttpRequest();
					xhr.open("GET", file);

					xhr.onload = function() {
						if (xhr.readyState == 4 && (xhr.status == 200 || xhr.status == 0)) {
				 			resolve(xhr.responseText);
						}
						else {
							reject(Error("An occured while loading file " + file + ". Status : " + xhr.statusText));
						}
					}

					xhr.onerror = function() {
						reject(Error("An occured while loading file " + file + ". Status : " + xhr.statusText));
					}

					xhr.send(); 
				})
			}

			function play() {
				var gameEnded = false;

				var boxWidth = 20;
				var boxHeight = 20;
				var circleSpace = 15;
				var circleRadius = 4;

				var loader = createFileLoader('level1.txt', null).then(function(response) {
					var renderer = SQUARE.getRenderer('mycanvas');

					var scene = SQUARE.createScene();
					scene.activeBorder(true);
					scene.setGradientBackgroundColor({startingColor : 'grey', endingColor : 'lightblue', mode : 'horizontal'});

					var boxes = [];
					var circles = [];

					var player;
					var idBox = 0;
					var level = response.split(/[\r\n]+/);
					for (var y = 0; y < level.length; y++) {
						for (var x = 0; x < level[y].length; x++) {
							if (level[y][x] === 'b') {
								var box = SQUARE.createBox({id : 'box_' + idBox, x : (x * boxWidth), y : y * boxHeight, width : boxWidth, height : boxHeight});
								boxes.push(box);
								scene.addChild(box);
								idBox++;
							}
							if (level[y][x] === 'o') {
								var circle = SQUARE.createCircle({x : (x * boxWidth) + (boxWidth / 2), y : (y * boxHeight) + (boxHeight / 2) + 5, radius : circleRadius, fillStyle : "#008000"});
								circles.push(circle);
								scene.addChild(circle);
							}
							if (level[y][x] === 'p') {
								player = SQUARE.createBox({id : 'player', x : x * 10, y : y * 10, width : 10, height : 10, gravity : gravity, fillStyle : "SaddleBrown"});
								scene.addChild(player);
							}
						}
					}


					var lifeBar = SQUARE.createBox({x : player.position.x - 3, y : player.position.y - 15, width : 15, height : 3, fillStyle : "#000000"});
					lifeBar.timeBetweenFrames = (1 / (lifeBar.width / lifetime)) / 2;
					lifeBar.referenceTime = new Date().getDate();
					scene.addChild(lifeBar);

					var looserText = SQUARE.createText({id : 'winnerText', text : 'Perdu! Rejouer? (O)', x : sceneWidth / 2 - 85, y : sceneHeight / 2, font : 'bold 24px cursive sans-serif', isVisible : false, fontColor: 'blue'});
					var pauseText = SQUARE.createText({id : 'pauseText', text : 'Pause...', x : sceneWidth / 2 - 55, y : sceneHeight / 2, font : 'bold 24px cursive sans-serif', isVisible : false, fontColor: 'crimson'});

					scene.addChild(looserText).addChild(pauseText);

					var keyboard = scene.keyboard.create();

					keyboard.when('keydown').then(function(key) {
						if (!scene.isPaused()) {
							if (key.keyCode === direction.RIGHT) {
								player.velX = friction;
							}

							if (key.keyCode === direction.LEFT) {
								player.velX = -friction;
							}

							if (key.keyCode === direction.UP) {
								if (!player.isJumping) {
									player.velY = -bounce;
									player.isGrounded = false;
									player.isJumping = true;
								}
							}
						}

						if (key.keyCode === 79) {
							if (gameEnded) {
								play();
							}
						}
					
						if (key.keyCode === 80) {
							scene.pause();
							pauseText.isVisible = !pauseText.isVisible
						}
					})

					keyboard.when('keyup').then(function(key) {
						if (key.keyCode === direction.RIGHT || key.keyCode === direction.LEFT) {
							player.velX = 0;
						}
					});

					scene.onTick().then(function() {
						var now = new Date().getTime();
						lifeBar.position.x = player.position.x - 3;
						lifeBar.position.y = player.position.y - 5;

						var timeForThisFrame = now;
						var timeElapsed = (timeForThisFrame - lifeBar.referenceTime) / 1000;

						if (timeElapsed > lifeBar.timeBetweenFrames) {
							lifeBar.width -= 0.5;
							lifeBar.position.x += 0.5;
							lifeBar.referenceTime = now;
						}

						if (lifeBar.width <= 0) {
							looserText.isVisible = true;
							gameEnded = true;
						}

						if (gameEnded) {
							scene.pause();
						}

						player.isGrounded = false;
					});

					scene.when(player).onCollisionWith(boxes).then(function(info) {
						// var top = false
						// var bottom = false;

						// if (player.position.y + player.height > info.collisioner.position.y && player.position.y < info.collisioner.position.y &&
						// 	(player.position.x + player.width > info.collisioner.position.x || player.position.x < info.collisioner.x + info.collisioner.width)) {
						// 	player.isJumping = false;
						// 		player.isGrounded = true;
						// 		player.position.y = info.collisioner.position.y - player.height;
						// 		player.position.x += info.collisioner.velX;
						// 		player.velY = 0;
						// 		top = true;
						// }
						// else if (player.position.y < info.collisioner.position.y + info.collisioner.height && player.position.y + player.height > info.collisioner.position.y + info.collisioner.height &&
						// 	(player.position.x + player.width > info.collisioner.position.x || player.position.x < info.collisioner.x + info.collisioner.width)) {
						// 	player.velY = -player.velY;
						// 		player.position.y = info.collisioner.position.y + info.collisioner.height;
						// 		bottom = true;
						// }
						// else if (player.position.x + player.width > info.collisioner.position.x &&
						// 	((player.position.y > info.collisioner.position.y && player.position.y + player.height < info.collisioner.position.y + info.collisioner.height))) {
						// 	player.isJumping = false;
						// 	player.position.x = info.collisioner.position.x - player.width;
						// 	player.velX = 0;
						// }
						// var vX = (info.collisioner.position.x + (info.collisioner.width / 2)) - (player.position.x + (player.width / 2));
				  //       var vY = (info.collisioner.position.y + (info.collisioner.height / 2)) - (player.position.y + (player.height / 2));
				  //       // add the half widths and half heights of the objects
				  //       var hWidths = (player.width / 2) + (info.collisioner.width / 2);
				  //       var hHeights = (player.height / 2) + (info.collisioner.height / 2);

				  //       var oX = hWidths - Math.abs(vX); 
				  //       var oY = hHeights - Math.abs(vY);

				  //       if (oX >= oY) {
				  //           if (vY > 0) {
				  //               player.isJumping = false;
						// 		player.isGrounded = true;
						// 		player.position.y = info.collisioner.position.y - player.height;
						// 		player.position.x += info.collisioner.velX;
						// 		player.velY = 0;
				  //           } else {
				  //               player.velY = -player.velY;
						// 		player.position.y = info.collisioner.position.y + info.collisioner.height;
				  //           }
				  //       } else {
				  //           if (vX > 0) {
				  //               player.isJumping = false;
						// 		player.position.x = info.collisioner.position.x - player.width;
						// 		player.velX = 0;
				  //           } else {
				  //               player.isJumping = false;
						// 		player.position.x = info.collisioner.position.x + info.collisioner.width;
						// 		player.velX = 0;
				  //           }
				  //       }
						    
						
						if (info.where === 'bottom') {
							player.velY = -player.velY;
							player.position.y = info.collisioner.position.y + info.collisioner.height;
						}

						if (info.where === 'top') {
							player.isJumping = false;
							player.isGrounded = true;
							player.position.y = (info.collisioner.position.y - player.height);
							player.position.x += info.collisioner.velX;
							player.velY = 0;
						}

						if (info.where === 'left') {
							
								player.isJumping = false;
								player.position.x = info.collisioner.position.x - player.width;
								// if (info.collisioner.getCenterPositionY() < player.getCenterPositionY()) {
								//player.velX = 0;
							 //}
						}

						if (info.where === 'right') {
							
								player.isJumping = false;
								player.position.x = info.collisioner.position.x + info.collisioner.width;
								//if (info.collisioner.getCenterPositionY() < player.getCenterPositionY()) {
								//player.velX = 0;
							//}
						}
					});

					scene.when(player).onCollisionWith(circles).then(function(info) {
						info.collisioner.isVisible = false;
						player.score += 5;
						if (lifeBar.width < 15) {
							lifeBar.width += 1;
						}
					});

					drawScene();

					function drawScene() {
						renderer.render(scene);

						requestAnimationFrame(drawScene);
					}

					scene.when(player).onCollisionWithBorder().then(function(info) {
					if (info.where === 'borderLeft') {
						player.velX = 0;
						player.position.x = 0;
					}

					if (info.where === 'borderRight') {
						player.velX = 0;
						player.position.x = sceneWidth - player.width;
					}

					if (info.where === 'borderBottom') {
						looserText.isVisible = true;
						gameEnded = true;
						// player.velY = 0;
						// player.position.y = sceneHeight - player.height;
						// player.isJumping = false;
					}
				});

				}, function(error) {
					console.log(error);
				});

				
			}

		</script>
	</body>
</html>